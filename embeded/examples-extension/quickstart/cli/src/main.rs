use std::path::PathBuf;

use clap::Parser;
use libdeno::x;
use libdeno::x::url;
use libdeno::core::anyhow::Context as _;
use libdeno::runtime::deno_core::anyhow;
use libdeno::runtime::worker::{MainWorker, WorkerOptions};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let args = Cli::parse();

    let module_url = url::resolve_path(&args.js_path).context("resolve module url")?;

    let service_options = x::runtime::new_worker_service_options();
    let worker_options = WorkerOptions {
        startup_snapshot: Some(SNAPSHOT),
        // @note: 重新注入拓展避免 MainWorker 的默认拓展确实 greeter::hello_world 导致 ops 数目和快照的不一致而报错的问题。
        extensions: vec![ext::hello_world::init()],
        ..Default::default()
    };

    let mut worker = MainWorker::bootstrap_from_options(&module_url, service_options, worker_options);
    worker
        .execute_main_module(&module_url)
        .await
        .context("exec main module")?;
    worker.run_event_loop(false).await.context("run event loop")
}

#[derive(Parser)]
struct Cli {
    /// 待执行的 JS 文件路径。
    #[clap(short, long, default_value = "static/app.js")]
    js_path: PathBuf,
}

// Load the snapshot generated by build.rs:
static SNAPSHOT: &[u8] = include_bytes!(std::concat!(env!("OUT_DIR"), "/", env!("CARGO_PKG_NAME"), ".snapshot"));
